import std.stdio;
import std.conv;
import std.typecons;
import std.algorithm: splitter, map;
import std.array: array, insertInPlace, join;


enum TokenKind { num, comma, equal, plus, dash, slash, star, let, ident, lparen, rparen, colon, unknown }


// ============================================================================
// lexing =====================================================================
// ============================================================================
class Token {
public:
    this(TokenKind kind) {
        this.kind = kind;
    }

    this(TokenKind kind, string ident) {
        this.kind = kind;
        this.ident = ident;
    }

    this(TokenKind kind, double value) {
        this.kind = kind;
        this.value = value;
    }

public:
    TokenKind kind;
private:
    union {
        string ident;
        double value;
    }
}

class Lexer {
public:
    this(string source) {
        offset = 0;
        tokens = [];
        for (size_t i; i < source.length; i += 1) {
            switch (source[i]) {
                case ' ': continue;
                case '=': tokens.insertInPlace(tokens.length, new Token(TokenKind.equal)); continue;
                case ',': tokens.insertInPlace(tokens.length, new Token(TokenKind.comma)); continue;
                case '+': tokens.insertInPlace(tokens.length, new Token(TokenKind.plus)); continue;
                case '-': tokens.insertInPlace(tokens.length, new Token(TokenKind.dash)); continue;
                case '/': tokens.insertInPlace(tokens.length, new Token(TokenKind.slash)); continue;
                case '*': tokens.insertInPlace(tokens.length, new Token(TokenKind.star)); continue;
                case '(': tokens.insertInPlace(tokens.length, new Token(TokenKind.lparen)); continue;
                case ')': tokens.insertInPlace(tokens.length, new Token(TokenKind.rparen)); continue;
                case ':': tokens.insertInPlace(tokens.length, new Token(TokenKind.colon)); continue;
                default: break;
            }

            if ('0' <= source[i] && source[i] <= '9') {
                double value = source[i] - '0';
                tokens.insertInPlace(tokens.length, new Token(TokenKind.num, value));
                continue;
            }

            if ('a' <= source[i] && source[i] <= 'z') {
                if (i + 3 < source.length && source[i..i+3] == "let") {
                    tokens.insertInPlace(tokens.length, new Token(TokenKind.let, source[i..i+3]));
                    i += 2;
                    continue;
                }
                tokens.insertInPlace(tokens.length, new Token(TokenKind.ident, source[i..i+1]));
            }
        }

        tokens.insertInPlace(tokens.length, new Token(TokenKind.unknown));
    }

    Token current() { 
        return tokens[offset];
    }

    Token consume() {
        Token token = tokens[offset];
        offset += 1;
        return token;
    }

public:
    Token[] tokens;
    int offset;
}



// ============================================================================
// parsing ====================================================================
// ============================================================================
enum BinOpKind { add, sub, mul, div }

class BinOp {
public:
    this(BinOpKind kind) {
        this.kind = kind;
    }

public:
    BinOpKind kind;
    Expr left;
    Expr right;
}


class FnCall {
public:
    this(string name) {
        this.name = name;
        args = [];
    }

    void push(Expr expression) {
        args.insertInPlace(args.length, expression);
    }

public:
    string name;
    Expr[] args;
}

enum ExprKind { binop, num, variable, fn_call, negate }

class Expr {
public:
    this(ExprKind kind) {
        this.kind = kind;
    }

    this(ExprKind kind, double value) {
        this.kind = kind;
        this.value = value;
    }

public:
    ExprKind kind;
    double value;
    union {
        BinOp binary_op;
        FnCall fn_call;
        Expr negate;
    }
}


class FnDef {
public:
    this(Expr body) {
        this.body = body;
    }

public:
    string[] param_names;
    double[string] params;
    Expr body;
}

class Parser {
public:
    this(Eval eval) {
        this.eval = eval;
    }

    void parse(Lexer lexer) {
        this.lexer = lexer;
        this.eval = eval;
        parse_line;
    }

private:
    void parse_line() {
        if (this.lexer.current.kind == TokenKind.let) {
            this.lexer.consume;
            parse_def;

            return;
        }

        Expr expression = parse_expr_prec(0);
        if (expression is null) { return; }

        if (lexer.current.kind != TokenKind.unknown) { return; }

        double result = eval.evaluate(expression);
        writef("= %f\n", result);
    }

    void parse_def() {
        Token ident = lexer.consume;
        if (ident.kind != TokenKind.ident) {
            writef("missing identifier\n");
            return;
        }

        while (lexer.current.kind == TokenKind.ident) {
            lexer.consume;
        }

        if (lexer.current.kind != TokenKind.equal) {
            writef("expected '='\n");
            return;
        }


        lexer.consume;
        eval.definitions[ident.ident] = new FnDef(parse_expr_prec(0));
    }

    Expr parse_expr_prec(int prec) {
        Expr left = parse_expr_primary;
        if (left is null) { return null; }

        for (;;) {

            int op_prec;
            switch(lexer.current.kind) {
                case TokenKind.plus: case TokenKind.dash:
                    op_prec = 1;
                    break;

                case TokenKind.star: case TokenKind.slash:
                    op_prec = 2;
                    break;

                default:
                    op_prec = -1;
                    break;
            }

            if (op_prec == -1) { break; }
            if (prec >= op_prec) { break; }

            Expr operator = new Expr(ExprKind.binop);
            switch (lexer.consume.kind) {
                case TokenKind.plus: operator.binary_op = new BinOp(BinOpKind.add); break;
                case TokenKind.dash: operator.binary_op = new BinOp(BinOpKind.sub); break;
                case TokenKind.star: operator.binary_op = new BinOp(BinOpKind.mul); break;
                case TokenKind.slash: operator.binary_op = new BinOp(BinOpKind.div); break;
                default: break;
            }

            Expr right = parse_expr_prec(op_prec);
            if (right is null) { return null; }

            operator.binary_op.left = left;
            operator.binary_op.right = right;

            left = operator;
        }

        return left;
    }

    Expr parse_expr_primary() {
        Token token = lexer.current;
        switch (token.kind) {
            case TokenKind.num: return new Expr(ExprKind.num, lexer.consume.value);
            case TokenKind.ident: return parse_ident;
            case TokenKind.dash: return parse_negate;
            case TokenKind.lparen:
                lexer.consume;
                Expr expression = parse_expr_prec(0);
                if (lexer.current.kind != TokenKind.rparen) { writef("expected closing paren\n"); return null; }
                lexer.consume;
                return expression;
            default: writef("expected expression\n"); return null;
        }
    }

    Expr parse_ident() {
        Token ident = lexer.consume;
        Expr expr = new Expr(ExprKind.fn_call);
        expr.fn_call = new FnCall(ident.ident);

        if (lexer.current.kind != TokenKind.colon) {
            return expr;
        }
       
        // consume ':'
        lexer.consume;

        for (;;) {
            expr.fn_call.push(parse_expr_prec(0));
            if (lexer.current.kind != TokenKind.comma) { break; }
            lexer.consume;
        }

        return expr;
    }

    Expr parse_negate() {
        lexer.consume;
        Expr negate = new Expr(ExprKind.negate);
        negate.negate = parse_expr_primary;
        if (negate.negate is null) { writef("negate on non expression\n"); return null; }

        return negate;
    }

private:
    Lexer lexer;
    Eval eval;
}


class Eval {
public:
    this() {
        arg_stack = [];
    }

    double evaluate(Expr expr) {
        switch (expr.kind) {
            case ExprKind.num: return expr.value;
            case ExprKind.binop:
                final switch (expr.binary_op.kind) {
                    case BinOpKind.add: return evaluate(expr.binary_op.left) + evaluate(expr.binary_op.right);
                    case BinOpKind.sub: return evaluate(expr.binary_op.left) - evaluate(expr.binary_op.right);
                    case BinOpKind.mul: return evaluate(expr.binary_op.left) * evaluate(expr.binary_op.right);
                    case BinOpKind.div: return evaluate(expr.binary_op.left) / evaluate(expr.binary_op.right);
                }

            case ExprKind.negate: return -evaluate(expr.negate);

            case ExprKind.fn_call:
                if ((expr.fn_call.name in definitions) is null) {
                    writef("call to undefined variable\n");
                    return 0.0;
                }

                arg_stack.length += 1;
                FnDef[string] top;
                for (size_t i = 0; i < expr.fn_call.args.length; i += 1) {
                }

                FnDef def = definitions[expr.fn_call.name];
                double result = evaluate(def.body);
                arg_stack.length -= 1;
                return result;

            default:
                writef("Unhandled eval\n");
                return 0.0;
        }
    }

private:
    FnDef[string] definitions;
    double[string][] arg_stack;
}

void main(string[] args) {
    Eval eval = new Eval();
    Parser parser = new Parser(eval);

    for (;;) {
        string line = readln();
        Lexer lexer = new Lexer(line);
        parser.parse(lexer);
    }
}
